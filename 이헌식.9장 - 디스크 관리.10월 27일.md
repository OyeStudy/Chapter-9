메모리는 휘발성이기 때문에 전원이 나가면 메모리에 있던 내용이 사라지는데
컴퓨터에서 작업한 결과물들을 반영구적으로 보관하기 위해서는 디스크같은 2차 저장치가 필요로 한다. 이 디스크를 효율적으로 사용하기위해 디스크 스케줄링 기법과 저전력 디스크 관리 기법들에 대해 살펴본다.

# 1.Disk Structure(디스크의 구조)
 logical block(논리 블록)이란 저장은 섹터로 되어있지만, 외부에서는 논리적인 블록단위로 디스크를 바라본다. 쉬운 예로는 배열의 몇번째 원소를 달라 라는 식으로 요청을 하면 디스크의 외부에서 보는 디스크의 단위 정보 저장 공간들을 뜻하며,주소를 가진 1차원 배열처럼 취급을 하고, 정보를 전송하는 최소 단위를 말한다.
Sector(섹터)란 디스크 관리의 최소 단위를 뜻하며, Logical block(논리 블록)이 물리적인 디스크에 매핑된 위치를 한다. Sector 0은 최외곽 실린더의 첫 트랙에 있는 첫 번째 섹터이며, 공통적으로 0에는 부팅 관련 정보를 저장하고 있다.

 동영상강의에서 나오는 용어들이 있는데 
 - physical formatting (Low_level formatting)은 디스크를 처음 만들때 섹터단위로 나누며, 디스크를 컨트롤러가 읽고 쓸 수 있도록 섹터들로 나누는 과정이다.
각 섹터는 header + 실제 data(보통 512 bytes) + trailer로 구성하고,
header와 trailer는 sector number, ECC(Error-Correcting Code) 등의 정보가 저장되며 controller가 직접 접근 및 운영을 한다.
ECC는 본 데이터를 요약한 코드같은 것이다. 해쉬함수를 생각하면 된다. 예시로 나중에 데이터를 꺼내갈때, header와 trailer를 같이 읽는데, 거기에 header나 trailer에 저장되있던 ECC와 ECC를 만든값을 비교해서 같으면 베드섹터안나고 잘 저장되어있구나 확인하는 것이고, 좋은 해쉬함수 같은 것을 사용하면 상당부분 에러를 검출 가능하다. ECC의 규모에따라 에러의 검출뿐 아니라 수정까지 가능한 경우도 있다.
- Partitioning (파티셔닝)은 physical formating 후에 섹터 영역들을 묶는 것이고 예로는 하드디스크 하나를 사서 c드라이브, d드라이브로 파티셔닝하면 서로 다른 논리적 디스크가 되는데, 디스크를 하나 이상의 실린더 그룹으로 나누는 과정을 파티셔닝이라 한다. OS는 이것을 독립적 disk로 취급을 한다.(logical disk)
 Logical formatting(논리적 포맷)은 파티션에 파일 시스템을 설치하는 것을 뜻하며,
FAT, inode, free space 등의 구조 포함을 한다.
- Booting(부팅) 처음 부팅시 메모리는 비어있고,cpu는 메모리만 접근가능 하기때문에 하드디스크는 직접 접근을 못한다. 그러므로 전원이 나가더라도 내용이 유지되는 소량의 메모리인 ROM 에 small bootstrap loader 저장을 하고 전원을 키면 cpu제어권이 ROM으로 넘어가면 ROM에 있는 "small bootstrap loader"의 실행된다.
"small bootstrap loader"가 sector 0 (boot block)을 load하여 실행하도록 지시를 하고, sector 0은 "full Bootstrap loader program" 실행을 한다.
full Bootstrap loader program은 파일시스템에서 운영체제 커널의 위치를 찾아 실행하라고 명령하면, OS를 디스크에서 load하여 실행을 한다.

> 부트스트랩 로더(Bootstrap Loader)는 시스템의 부팅을 도와주는 제일 먼저 실행되는 코드라고 생각하면 되는 것이고, 일반적으로 ROM에 저장된 채로 항상 실행 가능할 수 있도록 존재하는 코드정도라고 생각하면 된다.

# 2.디스크 스케줄링
디스크 접근 시간은 Access time은 Seek time과 Rotational latency, Transfer time 으로 구분된다.
Seek time은 헤드를 해당 실린더로 움직이는데 걸리는 시간을 뜻하고,
안쪽 에서 바깥쪽 으로 바깥쪽 에서 안쪽으로 같은 트랙에 위치한 곳들을 모은 것을 실린더라고 부른다. 트랙이란 말과 비슷하게 사용되며, 가장 큰 시간구성요소이며 기계장치가 이동하기 때문에 반도체 등에 비해 매우 느리기 때문에 한번의 seek로 많은 양을 처리하면 유리하다고 한다. Disk Scheduling은  seek time을 최소화하는 것이 목표이이다.

![](https://velog.velcdn.com/images/hunsik0302/post/7e97c2ad-159b-42e9-a78d-e5f1a6360d1f/image.png)

- Disk Scheduling Algorithm
사실은 스케줄링 알고리즘이 구현되는 곳이 대부분 디스크 내부가 아니라 OS 쪽이라서, 정확한 실린더 위치를 모를 수 있다. 그러므로 스케줄러는 논리블럭 번호를 보고 스케줄링을 하고, 내부에서 sector 단위를 이용하는 것도 가능은 하다고 한다.

1) FCFS (First Come First Service) 스케줄링


![](https://velog.velcdn.com/images/hunsik0302/post/92168c58-07d3-4299-95e5-6132ca372761/image.png)

위 사진과 같이 그냥 들어온 순서대로 처리를 한다.
안쪽과 바깥쪽이 번갈아 요청이 들어오는 경우 seek time이 늘어나 비효율적 이다.

2) SSTF (Shortest Seek Time First) 스케줄링

![](https://velog.velcdn.com/images/hunsik0302/post/56462d83-428f-4159-ae8c-bc57b37868af/image.png)

위 사진과 같이 제일 가까운 요청 먼저 처리를 하며, starvation 문제가 있고 한쪽에만 머물 가능성이 있어 자칫 기아 현상을 발생 시킬수 있다.

3) SCAN 알고리즘

![](https://velog.velcdn.com/images/hunsik0302/post/b1b71cda-0f0b-453b-8ad6-d90287fe8ee2/image.png)

엘레베이터 스케줄링이라고도 한다. 기본적으로 디스크 스케줄링은 SCAN에 기반해서 사용을 하고, disk arm이 디스크의 한쪽 끝에서 다른쪽 끝으로 이동하며 가는 길목에 있는 모든 요청을 처리한다. 다른 한쪽 끝에 도달하면 역방향으로 이동하며 오는 길목에 있는 모든 요청을 처리하며 다시 반대쪽 끝으로 이동한다. 문제점으로는 실린더 위치에 따라 대기시간이 다르기때문 최악의 경우 왕복 전체를 기다려야한다. 쉬운 예로는 가장자리의 요청이 들어왔는데 헤드가 막 떠난 경우를 말한다.

4) C-SCAN 알고리즘

![](https://velog.velcdn.com/images/hunsik0302/post/ebe0ec0b-6695-4572-940a-36d31f8ce239/image.png)

C-SCAN (Circular SCAN) 알고리즘은 헤드가 한쪽 끝에서 다른쪽 끝으로 이동하며 가는 길목에 있는 모든 요청을 처리를 하고 다른쪽 끝에 도달했으면 요청을 처리하지 않고 곧바로 출발점으로 다시 이동을 한다. 이동 거리는 길어질 수 있으나, SCAN보다 균일한 대기 시간을 제공한다.

5) LOOK and C-LOOK 알고리즘

![](https://velog.velcdn.com/images/hunsik0302/post/fd8a3f00-b18f-4a67-95de-c2796aab5b3e/image.png)

SCAN과 C-SCAN의 비효율 개선을한 스케줄링 방식이다. 해당 방향에 요청이 없어도 끝까지 이동하는 단점을 해당 방향에 더 이상 요청이 없으면 끝까지 이동하지 않고 방향을 바꾼다. 위 그림을 보면 맨 끝까지 이동하지않고, 14, 183에서 방향을 전환한 것을 확인할 수 있다.
 
 
# 3.다중 디스크 환경에서의 스케줄링
포털 사이트 등 동시 사용자를 서비스하는 서버에서는 다수의 디스크를 함께 사용하게 되고 동일한 정보를 여러 디스크에 중복 저장함으로써 인기 데이터를 여러 디스크로부터 동시에 서비스하고, 일부 디스크에 오류가 발생해도 지속적인 서비스가 가능하며, 정보의 유실을 방지하여 신뢰성을 확보할수 있다. 이러한 환경에서는 같은 데이터가 저장되어 있는 여러 개의 디스크 중 어느 디스크에서 요청을 처리할지 결정하는 스케줄링 문제가 발생을하며 이러한 시스템에서는 스케줄링의 목표에 따라 요청을 처리할 디스크를 결정하는 기준이 달라진다. 예로는 탐색시간을 줄이는 것이 목표라면 여러 디스크 중에서 헤드의 현재 위치가 요청한 데이터와 가장 가까운 데이터를 선택하는 방법을 사용할수 있으며 거시적인 관점에서는 각 디스크 간의 부하균형을 이루도록 스케줄링하는것이 중요하다. 일부 디스크가 과부하 상태에 이르지 않고 모든 디스크에 요청이 골고루 분배되도록 스케줄링을 해야하기 때문이다. 전력 소모를 줄이는 측면에서는 모든 디스크에 요청을 골고루 분배시키기보다는 일부 디스크에 요청을 집중시켜 나머지는 회전을 정지시키는것이 효율적이며, 일부 디스크만으로 요청을 충분히 처리할 수 있는 상황 안에서만 성립한다.이를 부하편향 기법이라고 한다.

# 4.디스크의 저전력 관리

1) 비활성화 기법
비활성화 기법은 active(활성상태),idle(공회전상태),standby(준비상태),sleep(휴면상태)로 나눌수 있고 active(활성상태)는 현재 헤드가 데이터를 읽거나 쓰고 있는 상태를 말하며,idle(공회전상태)는 디스크가 회전 중이지만 데이터를 읽거나 쓰지는 않는 상태이고, standby(준비상태)는 디스크가  회전하지 않지만 인터페이스가 활성화된 상태이며,sleep(휴면상태)는 디스크가 회전하지 않고 인터페이스도 비활성화 된상태를 말합니다.
디스크가 회전중인 활동 상태와 공회전 상태를 활성 상태라 부르고, 디스크가 정지한 준비 상태와 휴면 상태를 비활성 상태라고 부르며 요청이 없을 경우 디스크를 정지시키는 것이 전력 절감 측면에서 효율적이지만, 상태 전환시 부가적인 전력 및 시간이 소모되므로 후속 요청까지의 시간 간격이 일정 시간 이상일 경우에만 디스크의 회전을 정지시키는 것이 전력 소모를 절감하는 데 효과적이며 장치를 비활성화할 시점을 결정하기 위해 미래의 요청이 도착하는 시점과 간격을 정확히 예측하는 것이 중요함을 말한다.
디스크를 비활성화하는 시점을 결정하는 방법으로는 아래와 같이 3가지 기법이 있다. 

- timeout based (시간기반 기법)
일정 시간 동안 디스크가 공회전 상태이면 장치를 정지시켰다가, 다시 요청이 들어왔을때 디스크를 활성하는 기법이다.
- predication based (예측기반 기법)
과거 요청을 관찰하여 다음 공회전 구간의 길이를 예측한후 디스크를 비활성화할 시점을 결정하는 기법이다.
- stochastic based (확률기반 기법)
디바이스의 상태변경 시간 간격을 구하기 위해 확률분포를 통해 요청을 모델링하고 마르코프 체인 등과 같은 통계적 모델 이용하는 기법이다.

2) 회전속도 기법
회전속도 기법은 디스크의 회전속도를 가변적으로 조절하는 기법이며, 운영체제는 시스템자원과 부하를 포괄적으로 볼 수 있기 때문에 하드웨어 혼자서 전력 관리를 하는 것에 비해 더 많은 전력 절감 효과를 얻을 수 있다. 워크로드 특성을 활용해 회전속도를 조절하려는 시도, 멀티미디어 환경에서 저전력을 위한 디스크 스케줄링 으로 23%까지 전력 소모를 줄인 연구와 실시간 응용프로그램의 재생률과 버퍼 크기에 따라 디스크의 회전 속도를 조절해서 전력 소모를 줄이는 기법 등인 제안되어있다.
> 워크로드란 주어진 기간에 시스템에 의해 실행되어야 할 작업의 할당량을 의미함.

3) 디스크의 데이터 배치 기법
디스크 용량은 빠른 속도로 증가하고 있으나 디스크의 접근 속도는 기계적 매커니즘으로 인해 발전이 없는 실정이며 미시간대학교의 신강근 교수팀은 컴퓨터 시스템에서 디스크의 50%이상이 빈 공간이 상태로 남아 있다는 점을 착안하여 디스크 내에 데이터의 복제본을 많이 만들어 헤드 위치에 가까운 복제본에 접근하도록 하여 빠른 응답시간과 전력 소모량 절감을 얻는 FS2 파일 시스템 (free space file system) 을 제안하였다.

4) 버퍼캐싱 및 사전인출 기법
미래에 요청될 데이터를 알거나 예측할 수 있다면 디스크가 활성 상태일때 헤드위치로부터 가까운 데이터를 사전인출함으로써 향후 디스크의 비활성화 가능성을 높여 전력소모를 줄일 수 있으며 데드라인을 지켜 야하는 긴급 요청이 아닌 경우 디스크의 활성 상태 여부에 따라 요청을 최대한 지연시키는 방식으로 전력 소모를 줄일 수 있으며 이 둘을 통합하여 디스크가 저전력 모드일 때는 입출력 처리를 최대한 지연시켰다가 디스크가 정상 전력 모드로 돌아 왔을때 사전 인출을 공격적으로 하여 디스크의 상태 변화 횟수를 최소화하는 방법이 연구되었다 한다.

5) 쓰기전력을 통한 저전력 디스크 기법
대상 디스크가 비활성 상태일 때는 디스크 쓰기를 하지 않고 기다렸다가, 디스크가 활성 상태로 돌아왔을때 쓰는 방식으로 전력 소모를 줄이는 방안, 대상 디스크가 활성 상태가 아니면  일단 블록들을 로그 디스크에 썼다가 디스크가 활성 상태로 돌아 왔을 때 디스크에 쓰기연산을 수행하는 방안이 제안되었다.


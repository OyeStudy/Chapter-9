- 메모리는 휘발성 저장장치이므로 전원이 나가면 그 내용이 모두 사라진다. 따라서 컴퓨터에서 수행한 작업의 결과를 영구히 보관하기 위해서는 디스크와 같은 2차 저장장치를 이용해야 한다.

### 1. 디스크의 구조

- 디스크 외부에서는 디스크를 일정한 크기의 저장공간들로 이루어진 1차원 배열처럼 취급하게 된다.

- 이 일정한 크기의 저장공간을 논리블록(logical block)이라고 하며, 디스크에 데이터가 저장되거나 디스크 외부로 입출력이 일어날 때에 논리블록 단위로 저장 및 전송이 된다.

- 논리블록에 저장된 데이터를 접근하기 위해서는 배열에 접근하는 것처럼 해당 블록의 인덱스 번호를 디스크에 전달하면 디스크 컨트롤러는 해당 논리블록이 저장된 물리적 위치를 찾아 요청된 데이터에 대한 입출력 작업을 수행하게 된다.
=> 이때 각 논리블록이 저장되는 디스크 내의 물리적인 위치를 섹터(sector)라고 부른다.
==> 논리블록 하나가 섹터 하나와 1:1 매핑

- 디스크의 물리적인 구조
  - 마그네틱 원판으로 구성 n개
  - 각각의 원판은 트랙(track)으로 구성
  - 트랙은 섹터로 나뉨
  - 여러 개의 원판에서 상대적 위치가 동일한 트랙들의 집한 = 실린더(cylinder)
  => 섹터 0 : 최외곽 실린더의 첫 번째 트랙에 있는 첫 번째 섹터
  - 디스크 데이터를 읽고 쓰기 위해서는 암(arm)이 해당 섹터가 위치한 실린더로 이동한 후 원판이 회전하여 디스크 헤드가 저장된 섹터 위치에 도달해야 한다
  
![](https://velog.velcdn.com/images/bebeco_o/post/8c53523f-38ef-4326-803e-db56847d5000/image.png)



### 2. 디스크 스케줄링

- 디스크에 대한 접근시간(access time)은 `탐색시간(seek time)`과 `회전지연시간(rotational latency)`, `전송시간(transfer time)`으로 구분된다.

  - `탐색시간` : 
접근하려는 데이터가 원판의 안쪽에 있는지 바깥쪽에 있는지에 따라 헤드를 해당 실린더 위치로 이동시키는 데 걸리는 시간

  - `회전지연시간` :
디스크가 회전해서 읽고 쓰려는 섹터가 헤드 위치에 도달하기까지 걸리는 시간

  - `전송시간` :
해당 섹터가 헤드 위치에 도달한 후 데이터를 실제로 섹터에 읽고 쓰는 데 소요되는 시간

- 디스크의 입출력의 효율을 높이기 위해서는 디스크 입출력에 소요되는 접근시간을 최소화해야 한다.
=> `회전지연시간`과 `전송시간`은 상대적인 수치가 작을 뿐 아니라 운영체제 입장에서 통제하기 힘든 부분
=> 따라서 운영체제는 `탐색시간`을 줄이기 위해 헤드의 움직음을 최소하하는 스케줄링 작업을 한다.

- `디스크 스케줄링(disk scheduling)`
효율적인 디스크 입출력을 위해 여러 섹터들에 대한 입출력 요청이 들어왔을 때 이들을 어떠한 순서로 처리할 것인지 결정하는 메커니즘

#### 1) FCFS 스케줄링

- FCFS(First Come First Served) 스케줄링은 디스크에 먼저 들어온 요청을 먼저 처리하는 방식

![](https://velog.velcdn.com/images/bebeco_o/post/4241534a-9eb4-4aff-9806-10a77c9a9d96/image.png)

- FCFS 스케줄링이 적용되는 디스크에서 한쪽 끝과 반대쪽 끝에 도착하는 입출력 요청이 발생한다면 탐색시간이 매우 비효율적으로 늘어나는 결과를 초래한다.

#### 2) SSTF 스케줄링

- SSTF(Shortest Seek Time First) 스케줄링은 헤드의 현재 위치로부터 가장 가까운 위치에 있는 요청을 제일 먼저 처리하는 알고리즘

![](https://velog.velcdn.com/images/bebeco_o/post/b028685c-5cdf-43d8-835e-b62d592a6037/image.png)


- SSTF는 헤드의 이동거리를 줄여 디스크 입출력의 효율성을 증가시키지만, 자칫 `기아 현상(starvation)`을 발생시킬 수 있다.
=> 현재 헤드 위치로부터 가까운 곳에서 지속적인 요청이 있는 경우 헤드 위치에서 멀리 떨어진 곳의 요청은 무한히 기다려야하는 문제 발생

#### 3) SCAN 알고리즘

- SCAN 알고리즘은 헤드가 디스크 원판의 안쪽 끝과 바깥쪽 끝을 오가며, 그 경로에 존재하는 모든 요청을 처리한다.
=> 어떠한 위치에 요청이 들어오는가와 상관없이 헤드는 정해진 방향으로 이동하면서 길목에 있는 요청들을 처리하며 지나감

- SCAN 알고리즘은 일상생활에서 흔히 볼 수 있는 엘리베이터에서 사용하는 스케줄링 알고리즘과 유사하여 `엘리베이터 스케줄링 알고리즘(elevator scheduling algorithm)`이라고도 부른다. 

![](https://velog.velcdn.com/images/bebeco_o/post/39a43dd8-270d-4a6b-ab47-852418cbc7e1/image.png)

- SCAN 알고리즘에서 모든 실린더 위치의 기다리는 시간이 공편한 것은 아니다.
=> 헤드가 디스크 가장자리 실린더를 막 지나가고 나서 해당 위치에 요청이 들어오면 반대쪽 끝까지 헤드가 갔다 와야 서비스를 받을 수 있다.

- SCAN 알고리즘의 위치에 따른 탐색시간의 편차를 보완하기 위해 C-SCAN 알고리즘이 제안되었다.

#### 4) C-SCAN 알고리즘

- C-SCAN(Circular-SCAN) 알고리즘은 SCAN처럼 헤드가 한쪽 끝에서 다른 쪽 끝으로 이동하며 가는 길목에 있는 모든 요청을 처리한다.
=> SCAN과 달리 헤드가 다른 쪽 끝에 도달해 방향을 바꾼 후에는 요청을 처리하지 않고 곧바로 출발점으로 다시 이동
=> 각 실린더 위치에 대해 SCAN보다 좀 더 균일한 탐색시간을 제공

![](https://velog.velcdn.com/images/bebeco_o/post/498c26f5-1917-4f78-8e54-501ff7f1a2fb/image.png)

#### 5) LOOK과 C-LOOK 알고리즘

- LOOK 알고리즘은 헤드가 한쪽 방향으로 이동하다가 그 방향에 더 이상 대기 중인 요청이 없으면 헤드의 이동 방향을 즉시 반대로 바꾸는 스케줄링 방식

- C-LOOK 알고리즘은 전방에 요청이 없을 때 방향을 바꾼다는 측면에서는 LOOK과 유사하며, 한쪽 방향으로 이동할 때에만 요청을 처리한다는 점에서 C-SCAN과 유사하다.

![](https://velog.velcdn.com/images/bebeco_o/post/4e1f17e0-182a-45fa-bdaf-cc399ad9b384/image.png)

### 3. 다중 디스크 환경에서의 스케줄링

- 포털사이트 등 수많은 동시 사용자를 서비스하는 서버에서는 다수의 디스크를 함께 사용한다.
  - 동일한 정보를 여러 디스크에 중복 저장하여 인기 데이터를 여러 디스크로부터 동시에 서비스 가능
  - 일부 디스크에 오류가 발생해도 지속적인 서비스 가능
  - 정보의 유실을 방지
  => 다중 디스크를 사용하면 시스탬의 성능과 신뢰성을 동시에 향상
  

- 같은 데이터가 저장되어 있는 여러 개의 디스크 중 어느 디스크에서 요청을 처리할지 결정하는 스케줄링 문제가 발생한다.
=> 하나의 디스크 내에서 입출력 요청의 처리 순서 결정 + 다중 디스크에서는 스케줄링 작업을 수행할 디스크를 결정하는 문제

- 스케줄링의 목표에 따라 요청을 처리할 디스크를 결정하는 기준이 달라진다.
  - 탐색시간 줄이는 것이 목표
  여러 디스크 중에서 헤드의 현재 위치가 요청한 데이터와 가장 가까운 디스크를 선택하는 방법을 사용
  
- 디스크 간의 부하균형(load balancing)일 이루도록 스케줄링하는 것도 중요하다
  - 많은 요청을 동시에 처리할 수 있는 확장성 있는 서비스가 목표이므로 일부 디스크가 과부하 상태에 이르지 않고 모든 디스크에 요청이 골고루 분배되도록 스케줄링해야 한다.
  
### 4. 디스크의 저전력 관리

#### 1) 비활성화 기법

- 디스크의 상태는 전력 소모를 기준으로 크게 네 가지 상태로 나누어볼 수 있다.
`활동(active)상태` :
현재 헤드가 데이터를 읽거나 쓰고 있는 상태
`공회전(idle) 상태` :
디스크가 회전 중이지만 데이터를 읽거나 쓰지는 않는 상태
`준비(standby) 상태` :
디스크가 회전하지 않지만 인터페이스가 활성화된 상태
`휴면(sleep) 상태` : 
디스크가 회전하지 않고 인터페이스도 비활성화된 상태

![](https://velog.velcdn.com/images/bebeco_o/post/16f3cd98-f1b3-4650-8a60-806c8511e79d/image.png)

- 이미지를 보면 각 상태로 전환할 때는 부가적인 전력 및 시간이 소모된다.
=> 따라서 후속 요청까지의 시간 간격이 일정 시간(break-even time) 이상일 경우에만 디스크의 회전을 정지시키는 것이 전력 소모를 절감하는 데 효과적이다.

- 디스크를 비활성화하는 시점을 결정하는 방법
`시간기반(timeout based) 기법`
일정 시간 동안 디스크가 공회전 상태이면 장치를 정지시켰다가, 다시 요청이 왔을 때 디스크를 활성화
`예측기반(prediction based) 기법`
과거 요청을 관찰하여 다음 공회전 구간의 길이를 예측한 후 디스크를 비활성화할 시점을 결정
`확률기반(stochastic based) 기법`
디바이스의 상태변경 시간 간격을 구하기 위해 확률분포를 통해 요청을 모델링하고 마르코프 체인(Markov chain) 등과 같은 통계적 모델을 이용

#### 2) 회전속도 조절 기법

- 디스크의 전력 소모를 줄이기 위한 방법으로 최근에는 디스크의 회전속도(Rotations Per Minute:RPM)를 가변적으로 조절하는 기법이 제안되었다.

#### 3) 디스크의 데이터 배치 기법

- 미시간대학교 신강근 교수 팀이 대부분의 컴퓨터 시스템에서 디스크의 53% 이상이 빈 공간인 상태로 남아 있다는 점에 착안해, 디스크 내에 데이터의 복제본(replica)을 많이 만들어 헤드 위치에서 가까운 복제본에 접근하도록 함으로써 빠른 응답시간과 전력 소모량 절감을 얻는 FS2 파일 시스템(free space file system)을 제안했다.

#### 4) 버퍼캐싱 및 사전인출 기법

- 미래에 요청될 데이터를 미리 알거나 어느 정도 예측할 수 있다면 디스크가 활성 상태일 때 헤드 위치로부터 가까운 데이터를 사전인출(prefetching)함으로써 향후 디스크의 비활성화 가능성을 높여 전력 소모를 줄일 수 있는 기법이다.

#### 5) 쓰기전략을 통한 저전력 디스크 기법

- 저장장치의 데이터에 대한 쓰기전략(write strategy)을 통해 전력 소모를 줄이는 기법이다.

---
